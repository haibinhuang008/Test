# 网络

## http	

### 响应（respond）和请求（request）

#### 响应（respond）

##### 设置响应内容类型

```
//	为respond设置响应内容的类型
response.setContentType("application/vnd.ms-excel") 
```

MIME类型（Multipurpose Internet Mail Extensions）

- 在MIME类型（Multipurpose Internet Mail Extensions），`application`是一个顶级的类型，用于表示各种类型的数据，这些数据通常是供应用程序使用的，而不是直接供人类阅读的。MIME类型帮助邮件客户端、浏览器和其他应用程序确定如何处理接收到的数据。
- MIME类型由两部分组成，第一部分是媒体类型（type），第二部分是子类型（subtype）。
- application：表示这是一个应用程序类型的文件。vnd.ms-excel：是Vendor-specific（供应商特定的）MIME类型，用于Microsoft Excel文件。
- application/xml  application/pdf   application/zip

其他类型

- `image/gif`：GIF格式的图像。
- `text/plain`：普通的文本文件，如TXT文件。
- `audio/mpeg`：MPEG音频，如MP3文件。
- `video/mp4`：MP4视频格式。

##### 设置响应头

```
response.setHeader("Content-disposition", "attachment;filename=" + fileName + ".xlsx");
```

- `"Content-disposition"`：这是HTTP响应头的一个字段，用于告诉浏览器如何处理响应的内容。当它的值为`attachment`时，表示响应的内容应该被当作一个附件处理，即提示用户保存文件。
- `"Content-disposition"`：**inline**：当设置为`inline`时，浏览器会尝试在当前页面中直接打开文件，而不是提示用户保存。这通常用于图像或其他可以直接在浏览器中显示的文件类型。

# Java

## vo,dto,entity,pojo

1. **Entity（实体类）**：
   - 通常指的是直接与数据库表对应的Java对象。每个实体类通常包含一组属性，这些属性与数据库表中的列相对应。实体类通常用于ORM（对象关系映射）框架，如Hibernate或JPA，以便于数据库操作。
   - 实体类通常会包含一些注解，如`@Entity`、`@Table`、`@Id`、`@Column`等，这些注解用于定义实体与数据库表之间的关系。
2. **POJO（Plain Old Java Object，简单老式Java对象）**：
   - 指的是一个简单的Java对象，它没有遵循任何特定的Java EE或EJB规范，也没有实现任何特定的接口。POJO通常用于表示数据结构，不包含业务逻辑。
   - POJO可以是任何没有继承、实现接口或被注解的普通Java类。它们通常用于数据传输和简单的数据封装。
3. **DTO（Data Transfer Object，数据传输对象）**：
   - 用于在应用程序的不同层之间传输数据的对象。DTO通常用于表示客户端和服务器之间的数据交换格式，或者在应用程序的不同组件之间传递数据。
   - DTO通常包含一组属性，这些属性可能来自一个或多个实体类，或者包含一些不需要持久化到数据库的额外信息。DTO的目的是简化数据传输，而不是直接映射数据库表。
4. **VO（View Object，视图对象）**：
   - 用于表示Web页面或用户界面的数据模型。VO通常包含展示给用户的数据，这些数据可能来自一个或多个实体类，也可能包含一些计算字段或汇总数据。
   - VO的目的是简化视图层的数据处理，使得视图层的代码更加简洁和易于维护。

# SpringMVC

## 	DispatcherServlet

# Redis

## 介绍、特征和应用

一个开源的基于内存的键值对数据库。

**主要特征和作用**包括：

1、基于内存，读写速度极快，可以处理大量读写请求。

2、支持多种数据结构，如字符串、哈希、列表、集合、有序集合等，具有丰富的数据表示能力。

3、支持主从复制，提供数据冗余和故障恢复能力。

4、支持持久化，可以将内存数据保存到磁盘中。

5、支持事务，可以一次执行多个命令。

6、丰富的功能，可用于缓存、消息队列等场景。

**主要应用场景**包括：

1、缓存常见的使用场景，比如缓存查询结果、热点数据等，大大降低数据库负载。

2、处理大量的读写请求，比如访问统计、消息队列等。

3、排行榜、计数器等功能的实现。

4、pub/sub消息订阅。

5、QUE计划任务

6、分布式锁等。

## Redis穿透、击穿和雪崩

### 穿透

#### 概念

![image-20240908142406363](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20240908142406363.png)

#### 解决方法

Method1：数据库不存在这个数据时，也返回null给redis（可能会造成数据不一致的问题）

Method2：使用**布隆过滤器**

![image-20240908142922451](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20240908142922451.png)





### 击穿

#### 概念

![image-20240921122002574](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20240921122002574.png)

#### 解决方案

互斥锁：使用**互斥锁**重建缓存热点数据 ，可以保证数据的**强一致性**---- 缺点是**性能比较差**

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20240921122436143.png" alt="image-20240921122436143" style="zoom: 33%;" />

逻辑过期：设置**逻辑过期时间**，在数据过期后并不会被移除，而是读取逻辑过期数据，再重新构建热点数据，优点是**高可用**，**性能好**----缺点是**数据可能不一致**

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20240921123350150.png" alt="image-20240921123350150" style="zoom:33%;" />

### 雪崩

#### 概念

![image-20240921123304649](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20240921123304649.png)

#### 解决方法

![image-20240921123628665](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20240921123628665.png)

## 双写一致性

**延时双删策略**：在更新数据库后，首先删除缓存，然后经过一个短暂的延时（例如几百毫秒）再次删除缓存，以确保在这段时间内的数据更新操作已经完成，并且从数据库同步到缓存的数据是最新的。这种方法可以减少因缓存和数据库数据不一致而导致的问题，但它并不能保证绝对的一致性，且延时时间的选择需要根据实际业务情况进行调整

**分布式锁**：使用分布式锁可以确保在更新数据时，只有一个操作能够执行，从而避免并发写入导致的数据不一致问题。这种方法可以保证强一致性，但可能会影响系统的性能

**异步通知**：通过监听数据库的binlog事件，异步更新缓存。这种方法可以将缓存更新操作与主业务流程解耦，提高系统性能，但需要处理消息丢失或重复等问题，以确保缓存数据的最终一致性

**读写锁**：在读操作时使用共享锁，允许多个读操作并发执行；在写操作时使用排他锁，确保写操作独占资源。这样可以在保证一致性的同时，提高系统的并发性能

**多重保障方案**：结合同步删除、异步监听和可靠消息删除等策略，确保在各种情况下缓存和数据库的一致性。例如，先更新数据库再删除缓存，同时使用Canal监听binlog事件，通过消息队列异步删除缓存，以及设置缓存过期时间等

# MySQL

## 事务

### 概念

事务（Transaction）是数据库管理系统（DBMS）中的一个核心概念，用于确保数据的**完整性**和**一致性**。

### 事务的特性

1. **原子性（Atomicity）**：事务是数据库的逻辑工作单位，事务中包含的诸多操作要么全部完成，要么全部不完成，不会结束在中间某个点。
2. **一致性（Consistency）**：事务执行的结果必须是使数据库从一个一致性状态转换到另一个一致性状态。一致性状态是指数据库中的数据应满足业务规则和数据完整性约束。
3. **隔离性（Isolation）**：事务的执行不应互相干扰，即使有多个事务并发执行，每个事务都应感觉不到其他事务的存在，如同它们是依次执行的一样。不同的隔离级别会影响事务的隔离程度。
4. **持久性（Durability）**：一旦事务提交，则其所做的修改会永久保存在数据库中，即使系统发生故障也不会丢失。

### 事务的隔离等级

隔离性（Isolation）是事务的四个基本特性之一，它确保并发执行的事务之间的操作不会相互干扰。在没有适当隔离的情况下，事务可能会看到其他并发事务的中间状态，这可能导致各种问题，如脏读、不可重复读和幻读。

以下是隔离性的一些级别，以及它们如何影响事务处理的例子：

1. **读未提交（Read Uncommitted）**：
   - 在这个隔离级别下，一个事务可以读取另一个未提交事务的数据。
   - 例子：事务A更新了一条记录，但尚未提交。事务B读取了这条记录，然后事务A回滚了更改。事务B读取了一个从未实际存在过的数据，这就是**脏读**。
2. **读已提交（Read Committed）**：
   - 事务只能读取其他已提交事务的数据。
   - 例子：事务A更新了一条记录并提交。事务B稍后读取这条记录，会看到事务A的更改。这防止了脏读，但如果事务A在事务B读取后再次更新并提交，事务B再次读取时可能会得到不同的结果，这就是不可重复读。
3. **可重复读（Repeatable Read）**：
   - 在一个事务范围内，多次读取同一数据集合的结果都是一致的。
   - 例子：事务A读取了一条记录。在整个事务期间，即使其他事务更改并提交了这条记录，事务A再次读取时仍然会得到第一次读取时的数据。这防止了不可重复读，但如果其他事务插入了新记录，事务A可能无法看到这些新记录，这取决于数据库的实现。
4. **串行化（Serializable）**：
   - 这是最高的隔离级别，事务会依次顺序执行，模拟了没有并发执行的情况。
   - 例子：事务A和事务B都要更新同一条记录。在串行化隔离级别下，数据库会确保这两个事务不会同时执行，它们会一个接一个地执行，从而避免了幻读。

**例子**： 假设有一个银行账户表，账户ID为123的客户有1000元。

- 事务1（T1）：用户A进行取款操作，将账户ID为123的余额减少500元。
- 事务2（T2）：同时，用户B进行查询操作，检查账户ID为123的余额。

在不同的隔离级别下，可能会发生以下情况：

- **读未提交**：T1开始取款但未提交，T2查询余额可能会看到500元，即使T1的取款操作尚未完成。
- **读已提交**：T1完成取款并提交后，T2才能看到更新后的余额（500元）。
- **可重复读**：T2在整个事务期间，无论执行多少次查询，都会看到1000元，即使T1已经提交了取款操作。
- **串行化**：T1和T2的操作会串行执行，T2必须等到T1完成后才能执行，确保了完全的隔离。

### mvcc机制

多版本并发控制（MVCC）是一种数据库技术，用于提高并发性能，同时**保持数据的一致性和隔离性**。MVCC通过保存数据的多个版本，使得在不同的事务隔离级别下，事务可以读取到合适的数据版本，而不需要对数据行加锁，从而**减少了锁争用**，**提高了数据库的并发处理能力**

在MySQL的InnoDB存储引擎中，MVCC的实现依赖于几个关键组件：

1. **隐藏字段**：InnoDB为每行数据添加了三个隐藏字段，包括事务ID（`DB_TRX_ID`）、回滚指针（`DB_ROLL_PTR`）和行ID（`DB_ROW_ID`）。这些字段用于MVCC的版本控制和回滚操作

​	2.**Undo日志**：Undo日志记录了数据的历史版本，当数据被修改时，旧版本的数据会被保存在Undo日志中。这样，MVCC可以通过Undo日志来回滚到数据的旧版本，为不同事务提供一致性视图

​	3.**Read View**：Read View是一个事务在执行读取操作时创建的系统快照，它包含了在事务开始时所有活跃事务的ID列表。Read View用于确定事务能够看到哪些版本的数据，从而实现不同隔离级别下的数据可见性

## 索引

### 概念

索引是数据库的一种**数据结构**，用来提高数据库**检索效率**

## SQL优化方案
